<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Architecture Diagram (SVG)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #F3F4F6;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .container {
            background-color: #FFFFFF;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .btn-group {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .export-btn {
            padding: 12px 24px;
            background-color: #4A90D9;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(74, 144, 217, 0.3);
            transition: all 0.2s ease;
        }

        .export-btn:hover {
            background-color: #3A7BC8;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(74, 144, 217, 0.4);
        }

        .export-btn.secondary {
            background-color: #5BA55B;
        }

        .export-btn.secondary:hover {
            background-color: #4A944A;
        }

        svg {
            display: block;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
    </style>
</head>

<body>
    <div class="btn-group">
        <button class="export-btn" onclick="exportToSVG()">Export SVG</button>
        <button class="export-btn secondary" onclick="exportToPDF()">Export PDF</button>
    </div>
    <div class="container">
        <svg id="diagram" width="1050" height="670" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <!-- jsPDF library for PDF export -->
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <script>
        const svg = document.getElementById('diagram');
        const width = 1050;
        const height = 670;

        // Color palette
        const colors = {
            background: '#FAFBFC',
            presentationLayer: '#4A90D9',
            serviceLayer: '#5BA55B',
            businessLayer: '#E8913A',
            dataLayer: '#8E6BB8',
            componentBg: '#FFFFFF',
            text: '#1F2937',
            textLight: '#6B7280',
            textWhite: '#FFFFFF',
            arrow: '#6B7280',
            dataModule: '#8B5CF6',
            evalModule: '#10B981',
            llmModule: '#3B82F6'
        };

        // Helper function to create SVG elements
        function createSVGElement(tag, attrs = {}) {
            const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (const [key, value] of Object.entries(attrs)) {
                el.setAttribute(key, value);
            }
            return el;
        }

        // Draw background
        svg.appendChild(createSVGElement('rect', {
            x: 0, y: 0, width, height,
            fill: colors.background
        }));

        // Define shadow filter
        const defs = createSVGElement('defs');
        defs.innerHTML = `
            <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                <feDropShadow dx="0" dy="3" stdDeviation="5" flood-color="rgba(0,0,0,0.08)"/>
            </filter>
        `;
        svg.appendChild(defs);

        // Helper functions
        function drawRoundedRect(x, y, w, h, r, fill, stroke = null, shadowOn = false) {
            const rect = createSVGElement('rect', {
                x, y, width: w, height: h, rx: r, ry: r,
                fill,
                ...(stroke ? { stroke, 'stroke-width': 1.5 } : {}),
                ...(shadowOn ? { filter: 'url(#shadow)' } : {})
            });
            svg.appendChild(rect);
            return rect;
        }

        function drawText(text, x, y, size, color, align = 'middle', weight = 'normal') {
            const textEl = createSVGElement('text', {
                x, y,
                fill: color,
                'font-size': size,
                'font-weight': weight === '600' ? '600' : weight === '500' ? '500' : 'normal',
                'text-anchor': align === 'center' ? 'middle' : align,
                'dominant-baseline': 'middle',
                'font-family': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
            });
            textEl.textContent = text;
            svg.appendChild(textEl);
            return textEl;
        }

        function drawVerticalArrow(x, fromY, toY, color = colors.arrow) {
            const headLen = 6;
            const gap = 3;

            // Line
            const line = createSVGElement('line', {
                x1: x, y1: fromY + headLen + gap,
                x2: x, y2: toY - headLen - gap,
                stroke: color, 'stroke-width': 1.5
            });
            svg.appendChild(line);

            // Top arrow head
            const topArrow = createSVGElement('polygon', {
                points: `${x},${fromY} ${x - 5},${fromY + headLen} ${x + 5},${fromY + headLen}`,
                fill: color
            });
            svg.appendChild(topArrow);

            // Bottom arrow head
            const bottomArrow = createSVGElement('polygon', {
                points: `${x},${toY} ${x - 5},${toY - headLen} ${x + 5},${toY - headLen}`,
                fill: color
            });
            svg.appendChild(bottomArrow);
        }

        function drawLayerLabel(text, x, y, color) {
            const g = createSVGElement('g', {
                transform: `translate(${x}, ${y}) rotate(-90)`
            });

            // Measure text width (approximate)
            const textWidth = text.length * 7 + 24;

            const rect = createSVGElement('rect', {
                x: -textWidth / 2, y: -13,
                width: textWidth, height: 26,
                rx: 4, ry: 4, fill: color
            });
            g.appendChild(rect);

            const textEl = createSVGElement('text', {
                x: 0, y: 0,
                fill: colors.textWhite,
                'font-size': 11,
                'font-weight': '600',
                'text-anchor': 'middle',
                'dominant-baseline': 'middle',
                'font-family': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
            });
            textEl.textContent = text;
            g.appendChild(textEl);

            svg.appendChild(g);
        }

        // Layout
        const marginLeft = 80;
        const marginRight = 50;
        const layerWidth = width - marginLeft - marginRight;
        const startX = marginLeft;

        // === LAYER 1: Web Interface ===
        const layer1Y = 20;
        const layer1Height = 110;

        drawRoundedRect(startX, layer1Y, layerWidth, layer1Height, 10, colors.componentBg, colors.presentationLayer, true);
        drawLayerLabel('Web Interface', 45, layer1Y + layer1Height / 2, colors.presentationLayer);

        // Functional modules
        const moduleWidth = 190;
        const moduleHeight = 65;
        const moduleGap = 18;
        const totalModulesWidth = moduleWidth * 4 + moduleGap * 3;
        const moduleStartX = startX + (layerWidth - totalModulesWidth) / 2;
        const moduleY = layer1Y + 25;

        function drawModule(x, y, w, h, title, items, titleColor) {
            drawRoundedRect(x, y, w, h, 6, '#EFF6FF', '#BFDBFE');
            drawText(title, x + w / 2, y + 18, 11, titleColor, 'center', '600');
            items.forEach((item, i) => {
                drawText(item, x + w / 2, y + 36 + i * 13, 9, colors.textLight, 'center');
            });
        }

        drawModule(moduleStartX, moduleY, moduleWidth, moduleHeight,
            'Data Management', ['Tables, Ontologies', 'Ground Truth, Annotations'], colors.presentationLayer);

        drawModule(moduleStartX + moduleWidth + moduleGap, moduleY, moduleWidth, moduleHeight,
            'LLM Configuration', ['Model Settings', 'Prompt Templates'], colors.presentationLayer);

        drawModule(moduleStartX + (moduleWidth + moduleGap) * 2, moduleY, moduleWidth, moduleHeight,
            'Task Configuration', ['Batch Settings', 'Parameter Tuning'], colors.presentationLayer);

        drawModule(moduleStartX + (moduleWidth + moduleGap) * 3, moduleY, moduleWidth, moduleHeight,
            'Result Visualization', ['Annotations View', 'Evaluation Metrics'], colors.presentationLayer);

        // === LAYER 2: API Gateway ===
        const layer2Y = 155;
        const layer2Height = 55;

        drawRoundedRect(startX, layer2Y, layerWidth, layer2Height, 10, colors.componentBg, colors.serviceLayer, true);
        drawLayerLabel('API Gateway', 45, layer2Y + layer2Height / 2, colors.serviceLayer);

        drawText('Request Routing  •  Authentication', startX + layerWidth / 2, layer2Y + layer2Height / 2, 12, colors.textLight, 'center');

        // Arrow between layer 1 and 2
        drawVerticalArrow(width / 2, layer1Y + layer1Height + 5, layer2Y - 5, colors.arrow);

        // === LAYER 3: Core Engine ===
        const layer3Y = 235;

        const innerMargin = 18;
        const sideModuleWidth = 140;
        const centerWidth = layerWidth - innerMargin * 4 - sideModuleWidth * 2;
        const centerX = startX + innerMargin + sideModuleWidth + innerMargin;

        // Task Orchestrator
        const orchY = layer3Y + 15;
        const orchHeight = 50;

        // Annotation Engine
        const engineY = orchY + orchHeight + 12;
        const engineHeight = 120;

        // Evaluation
        const evalY = engineY + engineHeight + 12;
        const evalHeight = 50;

        // Side modules
        const sideModY = layer3Y + 15;
        const sideModHeight = (evalY + evalHeight) - sideModY;

        // Calculate layer3Height
        const layer3Height = (evalY + evalHeight) - layer3Y + 15;

        drawRoundedRect(startX, layer3Y, layerWidth, layer3Height, 10, colors.componentBg, colors.businessLayer, true);
        drawLayerLabel('Core Engine', 45, layer3Y + layer3Height / 2, colors.businessLayer);

        // === Left side module: Data Manager ===
        const leftModX = startX + innerMargin;

        drawRoundedRect(leftModX, sideModY, sideModuleWidth, sideModHeight, 6, '#F5F3FF', '#C4B5FD');
        drawText('Data Manager', leftModX + sideModuleWidth / 2, sideModY + 22, 12, colors.dataModule, 'center', '600');

        const leftItems = ['Table Loader', 'Ontology Loader', 'Annotation Writer'];
        const leftItemStartY = sideModY + 55;
        const leftItemGap = 42;
        leftItems.forEach((item, i) => {
            drawRoundedRect(leftModX + 10, leftItemStartY + i * leftItemGap, sideModuleWidth - 20, 28, 4, colors.componentBg, '#C4B5FD');
            drawText(item, leftModX + sideModuleWidth / 2, leftItemStartY + i * leftItemGap + 14, 10, colors.text, 'center', '500');
        });

        // === Center: Task Orchestrator + Annotation Engine + Evaluation ===

        // Task Orchestrator
        drawRoundedRect(centerX, orchY, centerWidth, orchHeight, 6, '#FEF3C7', '#FCD34D');
        drawText('Task Orchestrator', centerX + centerWidth / 2, orchY + 18, 13, colors.businessLayer, 'center', '600');
        drawText('Task Scheduling  •  State Management  •  Lifecycle Control', centerX + centerWidth / 2, orchY + 36, 10, colors.textLight, 'center');

        // Annotation Engine
        drawRoundedRect(centerX, engineY, centerWidth, engineHeight, 6, '#FFF7ED', '#FDBA74');
        drawText('Annotation Engine', centerX + centerWidth / 2, engineY + 18, 13, colors.businessLayer, 'center', '600');

        // Three components inside Annotation Engine
        const compGap = 15;
        const compWidth = (centerWidth - 30 - compGap * 2) / 3;
        const compHeight = 60;
        const compY = engineY + 42;
        const compStartX = centerX + 15;

        function drawEngineComp(x, y, w, h, title, desc) {
            drawRoundedRect(x, y, w, h, 6, colors.componentBg, '#FDBA74');
            drawText(title, x + w / 2, y + 22, 11, colors.text, 'center', '600');
            drawText(desc, x + w / 2, y + 42, 9, colors.textLight, 'center');
        }

        drawEngineComp(compStartX, compY, compWidth, compHeight, 'Ontology Navigator', 'BFS Traversal');
        drawEngineComp(compStartX + compWidth + compGap, compY, compWidth, compHeight, 'LLM Reasoner', 'Semantic Matching');
        drawEngineComp(compStartX + (compWidth + compGap) * 2, compY, compWidth, compHeight, 'Ensemble Aggregator', 'Voting & Consensus');

        // Evaluation
        drawRoundedRect(centerX, evalY, centerWidth, evalHeight, 6, '#ECFDF5', '#6EE7B7');
        drawText('Evaluation', centerX + centerWidth / 2, evalY + 18, 13, '#059669', 'center', '600');
        drawText('Precision / Recall Calculation  •  Experiment Comparison', centerX + centerWidth / 2, evalY + 36, 10, colors.textLight, 'center');

        // === Right side module: LLM Integration ===
        const rightModX = centerX + centerWidth + innerMargin;

        drawRoundedRect(rightModX, sideModY, sideModuleWidth, sideModHeight, 6, '#EFF6FF', '#93C5FD');
        drawText('LLM Integration', rightModX + sideModuleWidth / 2, sideModY + 22, 12, colors.llmModule, 'center', '600');

        const rightItems = ['Model Connector', 'Prompt Builder', 'Response Parser'];
        const rightItemStartY = sideModY + 55;
        const rightItemGap = 42;
        rightItems.forEach((item, i) => {
            drawRoundedRect(rightModX + 10, rightItemStartY + i * rightItemGap, sideModuleWidth - 20, 28, 4, colors.componentBg, '#93C5FD');
            drawText(item, rightModX + sideModuleWidth / 2, rightItemStartY + i * rightItemGap + 14, 10, colors.text, 'center', '500');
        });

        // Arrow between layer 2 and 3
        drawVerticalArrow(width / 2, layer2Y + layer2Height + 5, layer3Y - 5, colors.arrow);

        // === LAYER 4: Data Storage ===
        const layer4Y = layer3Y + layer3Height + 25;
        const layer4Height = 120;

        drawRoundedRect(startX, layer4Y, layerWidth, layer4Height, 10, colors.componentBg, colors.dataLayer, true);
        drawLayerLabel('Data Storage', 45, layer4Y + layer4Height / 2, colors.dataLayer);

        // Data stores
        const storeWidth = 180;
        const storeHeight = 70;
        const storeGap = 25;
        const storeTotalWidth = storeWidth * 4 + storeGap * 3;
        const storeStartX = startX + (layerWidth - storeTotalWidth) / 2;
        const storeY = layer4Y + 28;

        function drawStore(x, y, w, h, title, desc) {
            drawRoundedRect(x, y, w, h, 6, '#F5F3FF', '#DDD6FE');

            // Database icon
            const iconX = x + 22;
            const iconY = y + h / 2 - 5;

            // Top ellipse
            const topEllipse = createSVGElement('ellipse', {
                cx: iconX, cy: iconY - 8,
                rx: 10, ry: 5,
                fill: 'none', stroke: colors.dataLayer, 'stroke-width': 1.5
            });
            svg.appendChild(topEllipse);

            // Left line
            const leftLine = createSVGElement('line', {
                x1: iconX - 10, y1: iconY - 8,
                x2: iconX - 10, y2: iconY + 8,
                stroke: colors.dataLayer, 'stroke-width': 1.5
            });
            svg.appendChild(leftLine);

            // Right line
            const rightLine = createSVGElement('line', {
                x1: iconX + 10, y1: iconY - 8,
                x2: iconX + 10, y2: iconY + 8,
                stroke: colors.dataLayer, 'stroke-width': 1.5
            });
            svg.appendChild(rightLine);

            // Bottom arc
            const bottomArc = createSVGElement('path', {
                d: `M ${iconX - 10} ${iconY + 8} A 10 5 0 0 0 ${iconX + 10} ${iconY + 8}`,
                fill: 'none', stroke: colors.dataLayer, 'stroke-width': 1.5
            });
            svg.appendChild(bottomArc);

            drawText(title, x + w / 2 + 12, y + 25, 11, colors.text, 'center', '600');
            drawText(desc, x + w / 2 + 12, y + 48, 9, colors.textLight, 'center');
        }

        drawStore(storeStartX, storeY, storeWidth, storeHeight, 'Tables', 'Raw Data (CSV)');
        drawStore(storeStartX + storeWidth + storeGap, storeY, storeWidth, storeHeight, 'Ontologies', 'Domain Knowledge (OWL)');
        drawStore(storeStartX + (storeWidth + storeGap) * 2, storeY, storeWidth, storeHeight, 'Annotations', 'Run / Batch Results (JSON)');
        drawStore(storeStartX + (storeWidth + storeGap) * 3, storeY, storeWidth, storeHeight, 'Labels', 'Evaluation Ground Truth (CSV)');

        // Arrow between layer 3 and 4
        drawVerticalArrow(width / 2, layer3Y + layer3Height + 5, layer4Y - 5, colors.arrow);

        // Export to SVG function
        function exportToSVG() {
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'system_overview.svg';
            a.click();

            URL.revokeObjectURL(url);
        }

        // Export to PDF function (high resolution via Canvas)
        function exportToPDF() {
            const { jsPDF } = window.jspdf;
            const scale = 4; // High resolution scale factor

            // Serialize SVG to string
            const svgData = new XMLSerializer().serializeToString(svg);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = function () {
                // Create high-resolution canvas
                const canvas = document.createElement('canvas');
                canvas.width = width * scale;
                canvas.height = height * scale;
                const ctx = canvas.getContext('2d');

                // Fill white background
                ctx.fillStyle = '#FAFBFC';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw SVG at high resolution
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to PDF
                const imgData = canvas.toDataURL('image/png', 1.0);
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'pt',
                    format: [width, height]
                });

                pdf.addImage(imgData, 'PNG', 0, 0, width, height);
                pdf.save('system_overview.pdf');

                URL.revokeObjectURL(url);
            };

            img.src = url;
        }
    </script>
</body>

</html>
